@xor(x: bool, y: bool): bool {
  xn.1: bool = not x;
  yn.1: bool = not y;
  xyn.1: bool = and x yn.1;
  xny.1: bool = and xn.1 y;
  res.1: bool = or xyn.1 xny.1;
  ret res.1;
}
@getbit(x.2: int, position: int): bool {
  one.1: int = const 1;
  two.1: int = const 2;
  i.1: int = const 0;
.loop_cond:
  cond.1: bool = lt i.1 position;
  br cond.1 .loop_body .loop_exit;
.loop_body:
  x.2: int = div x.2 two.1;
  i.1: int = add i.1 one.1;
  jmp .loop_cond;
.loop_exit:
  halfx.1: int = div x.2 two.1;
  twohalfx.1: int = mul halfx.1 two.1;
  iszero.1: bool = eq twohalfx.1 x.2;
  res.1: bool = not iszero.1;
  ret res.1;
}
@rand(state: ptr<int>) {
  s.1: int = load state;
  two.1: int = const 2;
  one.1: int = const 1;
  head0_pos.1: int = const 11;
  head1_pos.1: int = const 13;
  head2_pos.1: int = const 14;
  head3_pos.1: int = const 16;
  head0.1: bool = call @getbit s.1 head0_pos.1;
  head1.1: bool = call @getbit s.1 head1_pos.1;
  head2.1: bool = call @getbit s.1 head2_pos.1;
  head3.1: bool = call @getbit s.1 head3_pos.1;
  fb.1: bool = call @xor head0.1 head1.1;
  fb.2: bool = call @xor fb.1 head2.1;
  fb.3: bool = call @xor fb.2 head3.1;
  s.2: int = mul s.1 two.1;
  s.4: int = id s.2;
  br fb.3 .add_one .end;
.add_one:
  s.4: int = add s.2 one.1;
.end:
  store state s.4;
}
@mod(x: int, m: int): int {
  q.1: int = div x m;
  multiple.1: int = mul q.1 m;
  r.1: int = sub x multiple.1;
  ret r.1;
}
@gen_uniform_csr(rows: int, cols: int, degree: int, csr_rowptr: ptr<int>, csr_colidx: ptr<int>, csr_values: ptr<int>) {
  one.1: int = const 1;
  zero.1: int = const 0;
  nnz.1: int = mul degree rows;
  store csr_rowptr zero.1;
  i.2: int = id one.1;
.loop_gen_rptr_cond:
  cond.1: bool = le i.2 rows;
  br cond.1 .loop_gen_rptr_body .loop_gen_rptr_exit;
.loop_gen_rptr_body:
  p.1: ptr<int> = ptradd csr_rowptr i.2;
  v.1: int = mul degree i.2;
  store p.1 v.1;
  i.2: int = add i.2 one.1;
  jmp .loop_gen_rptr_cond;
.loop_gen_rptr_exit:
  i.4: int = const 0;
  colidx_incr.1: int = div cols degree;
.loop_gen_cidx_cond:
  cond.2: bool = lt i.4 nnz.1;
  br cond.2 .loop_gen_cidx_body .loop_gen_cidx_exit;
.loop_gen_cidx_body:
  rid.1: int = div i.4 degree;
  v.2: int = mul i.4 colidx_incr.1;
  v.3: int = add v.2 rid.1;
  cid.1: int = call @mod v.3 cols;
  p.2: ptr<int> = ptradd csr_colidx i.4;
  store p.2 cid.1;
  i.4: int = add i.4 one.1;
  jmp .loop_gen_cidx_cond;
.loop_gen_cidx_exit:
  i.7: int = const 0;
  rng.1: ptr<int> = alloc one.1;
  seed.1: int = const 72160722;
  store rng.1 seed.1;
  ten.1: int = const 10;
.loop_gen_vals_cond:
  cond.3: bool = lt i.7 nnz.1;
  br cond.3 .loop_gen_vals_body .loop_gen_vals_exit;
.loop_gen_vals_body:
  call @rand rng.1;
  v.4: int = load rng.1;
  v.5: int = call @mod v.4 ten.1;
  p.3: ptr<int> = ptradd csr_values i.7;
  store p.3 v.5;
  i.7: int = add i.7 one.1;
  jmp .loop_gen_vals_cond;
.loop_gen_vals_exit:
  free rng.1;
  ret;
}
@gen_vec(len: int, data: ptr<int>) {
  one.1: int = const 1;
  i.1: int = const 0;
  rng.1: ptr<int> = alloc one.1;
  seed.1: int = const 85817256;
  store rng.1 seed.1;
  ten.1: int = const 10;
.loop_cond:
  cond.1: bool = lt i.1 len;
  br cond.1 .loop_body .loop_exit;
.loop_body:
  call @rand rng.1;
  v.1: int = load rng.1;
  v.2: int = call @mod v.1 ten.1;
  p.1: ptr<int> = ptradd data i.1;
  store p.1 v.2;
  i.1: int = add i.1 one.1;
  jmp .loop_cond;
.loop_exit:
  free rng.1;
  ret;
}
@csr_spmv(rows: int, cols: int, csr_rowptr: ptr<int>, csr_colidx: ptr<int>, csr_values: ptr<int>, vec: ptr<int>, res: ptr<int>) {
  one.1: int = const 1;
  zero.1: int = const 0;
  i.2: int = id zero.1;
.loop_init_cond:
  cond.1: bool = lt i.2 rows;
  br cond.1 .loop_init_body .loop_init_exit;
.loop_init_body:
  p.1: ptr<int> = ptradd res i.2;
  store p.1 zero.1;
  i.2: int = add i.2 one.1;
  jmp .loop_init_cond;
.loop_init_exit:
  rid.2: int = const 0;
.loop_rows_cond:
  cond.2: bool = lt rid.2 rows;
  br cond.2 .loop_rows_body .loop_rows_exit;
.loop_rows_body:
  p.2: ptr<int> = ptradd csr_rowptr rid.2;
  start.1: int = load p.2;
  p.3: ptr<int> = ptradd p.2 one.1;
  end.1: int = load p.3;
  j.2: int = add start.1 zero.1;
.loop_nnzs_cond:
  cond.3: bool = lt j.2 end.1;
  br cond.3 .loop_nnzs_body .loop_nnzs_exit;
.loop_nnzs_body:
  p.4: ptr<int> = ptradd csr_colidx j.2;
  cid.1: int = load p.4;
  p.5: ptr<int> = ptradd csr_values j.2;
  mat_val.1: int = load p.5;
  p.6: ptr<int> = ptradd vec cid.1;
  vec_val.1: int = load p.6;
  p.7: ptr<int> = ptradd res rid.2;
  acc.1: int = load p.7;
  incr.1: int = mul mat_val.1 vec_val.1;
  acc.2: int = add acc.1 incr.1;
  store p.7 acc.2;
  j.2: int = add j.2 one.1;
  jmp .loop_nnzs_cond;
.loop_nnzs_exit:
  rid.2: int = add rid.2 one.1;
  jmp .loop_rows_cond;
.loop_rows_exit:
  ret;
}
@print_arr(arr: ptr<int>, size: int) {
  one.1: int = const 1;
  i.2: int = const 0;
.loop_cond:
  cond.1: bool = lt i.2 size;
  br cond.1 .loop_body .loop_exit;
.loop_body:
  p.1: ptr<int> = ptradd arr i.2;
  v.1: int = load p.1;
  print v.1;
  i.2: int = add i.2 one.1;
  jmp .loop_cond;
.loop_exit:
  ret;
}
@main(rows: int, cols: int, degree: int) {
  one.1: int = const 1;
  rptr_len.1: int = add rows one.1;
  nnz.1: int = mul rows degree;
  csr_rowptr.1: ptr<int> = alloc rptr_len.1;
  csr_colidx.1: ptr<int> = alloc nnz.1;
  csr_values.1: ptr<int> = alloc nnz.1;
  call @gen_uniform_csr rows cols degree csr_rowptr.1 csr_colidx.1 csr_values.1;
  call @print_arr csr_rowptr.1 rptr_len.1;
  call @print_arr csr_colidx.1 nnz.1;
  call @print_arr csr_values.1 nnz.1;
  vec.1: ptr<int> = alloc cols;
  call @gen_vec cols vec.1;
  call @print_arr vec.1 cols;
  res.1: ptr<int> = alloc rows;
  call @csr_spmv rows cols csr_rowptr.1 csr_colidx.1 csr_values.1 vec.1 res.1;
  call @print_arr res.1 rows;
  free csr_rowptr.1;
  free csr_colidx.1;
  free csr_values.1;
  free vec.1;
  free res.1;
}
